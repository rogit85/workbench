/* workflow.js — robust, standalone workflow controller */
(function () {
  // ---- Utilities & fallbacks
  const has = (id) => document.getElementById(id);
  const noop = () => {};
  const addAudit = window.addAudit || noop; // fallback if host page didn’t define yet

  // ---- Stages model
  const STAGES = [
    { key: 'clearance', label: 'Clearance' },
    { key: 'review',    label: 'Submission Under Review' },
    { key: 'quoted',    label: 'Quoted' },
    { key: 'fon',       label: 'Firm Order Noted' },
    { key: 'bound',     label: 'Bound' },
    { key: 'booked',    label: 'Booked' }
  ];

  // Deep clone without structuredClone dependency
  const deepClone = (obj) => JSON.parse(JSON.stringify(obj));

  function defaultWorkflow() {
    return {
      current: 'review',
      stages: STAGES.map((s, i) => ({
        key: s.key,
        label: s.label,
        date: i <= 1
          ? new Date(Date.now() - ((STAGES.length - i) * 86400000)).toISOString()
          : null
      })),
      checks: {
        tasking:   { ops:false, issuance:false, compliance:false, wordings:false },
        items:     { sanctions:false, peer:false, referral:false, internalDocs:false, uwData:false, brokerDocs:false, brokerQueries:false, registering:false, issuance:false, booking:false }
      },
      comments: []
    };
  }

  // ---- Storage
  function wfKey() {
    const rid = (window.R && window.R.id) ? window.R.id : 'default';
    return 'workflow_' + rid;
  }
  function wfLoad() {
    try {
      const raw = localStorage.getItem(wfKey());
      return raw ? JSON.parse(raw) : defaultWorkflow();
    } catch {
      return defaultWorkflow();
    }
  }
  function wfSave() {
    localStorage.setItem(wfKey(), JSON.stringify(WF));
  }

  // ---- State (exposed on window for host page access)
  let WF = wfLoad();
  let PENDING = null;

  // ---- Public API
  function toggleWorkflow(open) {
    const el = has('workflowModal');
    if (!el) return;
    el.style.display = open ? 'flex' : 'none';
  }

  function openWorkflow() {
    renderWorkflow();
    toggleWorkflow(true);
  }

  // ---- Rendering
  function renderWorkflow() {
    // guard: if container isn’t on the page, bail silently
    if (!has('wfStages')) return;

    // timeline nodes
    has('wfStages').innerHTML = STAGES.map((s, i) => {
      const st  = (WF.stages || []).find(x => x.key === s.key) || {};
      const idx = Math.max(0, STAGES.findIndex(x => x.key === WF.current));
      const cls = (i < idx ? 'completed ' : '') + (i === idx ? 'active ' : '');
      const date = st.date ? new Date(st.date).toLocaleString() : '';
      return `
        <div class="wf-node ${cls}">
          <div class="wf-dot" onclick="wfAskStage('${s.key}')"></div>
          <div class="wf-label">${s.label}</div>
          <div class="wf-date">${date}</div>
        </div>`;
    }).join('');

    // progress fill
    const ci = Math.max(0, STAGES.findIndex(s => s.key === WF.current));
    if (has('wfLineFill')) {
      const denom = Math.max(1, STAGES.length - 1);
      has('wfLineFill').style.width = (ci / denom) * 100 + '%';
    }

    // tasking & items
    const taskRows = [
      {k:'ops',       label:'Tasked to Ops'},
      {k:'issuance',  label:'Tasked to Issuance Team'},
      {k:'compliance',label:'Tasked to Compliance Team'},
      {k:'wordings',  label:'Tasked to Wordings Team'}
    ];
    const itemRows = [
      {k:'sanctions',     label:'Sanctions Check Completed'},
      {k:'peer',          label:'Peer Review Completed'},
      {k:'referral',      label:'Referral Response Completed'},
      {k:'internalDocs',  label:'Internal Documents Storing Completed'},
      {k:'uwData',        label:'Underwriter Data Capture Completed'},
      {k:'brokerDocs',    label:'Broker Documents Completed'},
      {k:'brokerQueries', label:'Broker Queries Completed'},
      {k:'registering',   label:'Registering Completed'},
      {k:'issuance',      label:'Issuance Completed'},
      {k:'booking',       label:'Booking Completed'}
    ];

    if (has('wfTasking')) {
      has('wfTasking').innerHTML = taskRows.map(r => `
        <label class="wf-row">
          <input type="checkbox" ${WF.checks?.tasking?.[r.k] ? 'checked' : ''}
                 onchange="wfAskCheck('tasking','${r.k}', this.checked)">
          <span>${r.label}</span>
        </label>`).join('');
    }
    if (has('wfItems')) {
      has('wfItems').innerHTML = itemRows.map(r => `
        <label class="wf-row">
          <input type="checkbox" ${WF.checks?.items?.[r.k] ? 'checked' : ''}
                 onchange="wfAskCheck('items','${r.k}', this.checked)">
          <span>${r.label}</span>
        </label>`).join('');
    }

    if (has('wfConfirm')) has('wfConfirm').style.display = 'none';
    if (has('wfConfirmComment')) has('wfConfirmComment').value = '';

    // refresh icons if lucide present
    if (window.lucide && lucide.createIcons) lucide.createIcons();
  }

  // ---- Interactions (confirm bar)
  function wfAskStage(key) {
    PENDING = { type: 'stage', key, value: true };
    if (has('wfConfirm')) has('wfConfirm').style.display = 'flex';
    if (has('wfConfirmComment')) has('wfConfirmComment').focus();
  }

  function wfAskCheck(section, key, value) {
    PENDING = { type: 'check', section, key, value: !!value };
    if (has('wfConfirm')) has('wfConfirm').style.display = 'flex';
    if (has('wfConfirmComment')) has('wfConfirmComment').focus();
  }

  function wfConfirmPending() {
    const c = (has('wfConfirmComment') ? has('wfConfirmComment').value : '').trim();
    if (!c) { alert('Please add a comment.'); return; }
    const ts = new Date().toISOString();

    if (PENDING?.type === 'stage') {
      WF.current = PENDING.key;
      let passed = true;
      WF.stages = STAGES.map(s => {
        if (s.key === PENDING.key) { passed = false; return { key:s.key, label:s.label, date:ts }; }
        const prev = (WF.stages || []).find(x => x.key === s.key)?.date;
        return { key:s.key, label:s.label, date: passed ? (prev || ts) : null };
      });
      wfSave();
      const label = STAGES.find(s => s.key === PENDING.key)?.label || PENDING.key;
      addAudit('Workflow stage', `${label} • ${c}`);

    } else if (PENDING?.type === 'check') {
      WF.checks = WF.checks || { tasking:{}, items:{} };
      WF.checks[PENDING.section][PENDING.key] = !!PENDING.value;
      wfSave();

      const pretty = PENDING.section === 'tasking'
        ? {ops:'Tasked to Ops', issuance:'Tasked to Issuance Team', compliance:'Tasked to Compliance Team', wordings:'Tasked to Wordings Team'}[PENDING.key]
        : {sanctions:'Sanctions Check Completed', peer:'Peer Review Completed', referral:'Referral Response Completed',
           internalDocs:'Internal Documents Storing Completed', uwData:'Underwriter Data Capture Completed',
           brokerDocs:'Broker Documents Completed', brokerQueries:'Broker Queries Completed',
           registering:'Registering Completed', issuance:'Issuance Completed', booking:'Booking Completed'}[PENDING.key];

      addAudit('Workflow item', `${pretty} → ${PENDING.value ? 'Done' : 'Not done'} • ${c}`);
    }

    (WF.comments ||= []).unshift({ ts, user: (window.USER || 'User'), text: c, ctx: PENDING.type });
    wfSave();

    renderWorkflow();
    if (window.renderTimeline) window.renderTimeline();
    PENDING = null;
  }

  function wfCancelPending() {
    renderWorkflow();
    PENDING = null;
    if (has('wfConfirm')) has('wfConfirm').style.display = 'none';
  }

  function wfAddFreeComment() {
    const t = (has('wfFreeComment') ? has('wfFreeComment').value : '').trim();
    if (!t) return;
    (WF.comments ||= []).unshift({ ts: new Date().toISOString(), user: (window.USER || 'User'), text: t, ctx: 'comment' });
    wfSave();
    addAudit('Workflow comment', t);
    if (has('wfFreeComment')) has('wfFreeComment').value = '';
    renderWorkflow();
    if (window.renderTimeline) window.renderTimeline();
  }

  // ---- Expose API globally so your inline HTML handlers work
  window.openWorkflow     = openWorkflow;
  window.toggleWorkflow   = toggleWorkflow;
  window.renderWorkflow   = renderWorkflow;
  window.wfAskStage       = wfAskStage;
  window.wfAskCheck       = wfAskCheck;
  window.wfConfirmPending = wfConfirmPending;
  window.wfCancelPending  = wfCancelPending;
  window.wfAddFreeComment = wfAddFreeComment;

  // Optional: initialize storage once the Risk object exists
  window.addEventListener('load', () => {
    // If storage was for a different risk id, reload with correct key
    WF = wfLoad();
    renderWorkflow(); // harmless if modal not visible yet
  });
})();
